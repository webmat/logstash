input {
  file {
    codec => json
    path => [ '/usr/local/var/log/suricata/eve.json' ]
  }
}

filter {
  mutate { lowercase => ['event_type'] }
  # Drop all events not in supported list :,-(
  if [event_type] not in ['dns', 'alert', 'http', 'tls', 'fileinfo', 'ssh', 'stats', 'flow'] {
    drop {}
  }

  date {
    match => [ 'timestamp', 'ISO8601' ] # Timestamp truncated to milliseconds
    target => '@timestamp'
    remove_field => 'timestamp'
  }

  # ecs - common fields
  mutate {
    rename => {
      'event_type' => '[event][type]'
      'src_ip' => '[source][ip]'
      'src_port' => '[source][port]'
      'dest_ip' => '[destination][ip]'
      'dest_port' => '[destination][port]'
      'proto' => '[network][protocol]'
      'host' => '[host][name]'
    }
  }

  # remote-ness of addresses
  # geoip
  if [destination][ip] {
    cidr {
      address => '%{[destination][ip]}'
      network => ['10.0.0.0/8', '192.168.0.0/16', '172.16.0.0/12', 'fd00::/8']
      add_field => { '[destination][type]' => 'private' }
    }
    cidr {
      address => '%{[destination][ip]}'
      network => ['169.254.0.0/16', 'fe80::/10', '127.0.0.0/8', '0.0.0.0/8']
      add_field => { '[destination][type]' => 'local' }
    }
    if ![destination][type] { # Simplification. Not caring about carrier, multicast, etc.
      mutate { add_field => { '[destination][type]' => 'public'} }
    }
    if [destination][type] == 'public' {
      geoip {
        id => 'geoip-destination'
        source => '[destination][ip]'
        target => '[destination][geoip]'
        remove_field => ['[destination][geoip][ip]', '[destination][geoip][longitude]', '[destination][geoip][latitude]'] # Dupe info
      }
    }
    if '_geoip_lookup_failure' in [tags] {
      mutate {
        remove_field => ['[destination][geoip]']
      }
    }
  }

  if [source][ip] {
    cidr {
      id => 'cidr-private-source'
      address => '%{[source][ip]}'
      network => ['10.0.0.0/8', '192.168.0.0/16', '172.16.0.0/12', 'fd00::/8']
      add_field => { '[source][type]' => 'private' }
    }
    cidr {
      id => 'cidr-local-source'
      address => '%{[source][ip]}'
      network => ['169.254.0.0/16', 'fe80::/10', '127.0.0.0/8', '0.0.0.0/8']
      add_field => { '[source][type]' => 'local' }
    }
    if ![source][type] { # Simplification. Not caring about carrier, multicast, etc.
      mutate { add_field => { '[source][type]' => 'public'} }
    }
    if [source][type] == 'public' {
      geoip {
        id => 'geoip-source'
        source => '[source][ip]'
        target => '[source][geoip]'
        remove_field => ['[source][geoip][ip]', '[source][geoip][longitude]', '[source][geoip][latitude]'] # Dupe info
      }
    }
    if '_geoip_lookup_failure' in [tags] {
      mutate {
        remove_field => ['[source][geoip]']
      }
    }
  }
}

output {
  stdout { codec => dots }
  elasticsearch {
    user => elastic password => elastic
    index => 'suricata-%{[event][type]}-%{+YYYY.MM.dd}'
  }
}

